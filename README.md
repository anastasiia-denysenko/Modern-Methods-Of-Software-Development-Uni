# Четверта лабораторна робота
## Мова програмування: C++
### Чи є в цій мові концепції value types та reference types?
Так, в C++ є обидві ці концепції. Також в C++ є концепція pointer'а. 
- value type - значеннєвий тип даних. Його величина зберігається як фактичне значення. До нього в C++ відносяться: booleans, characters, integer numbers, floating-point numbers, classes та enumerations. Приклад створення: ```int x = 5.```
- reference type - посилальний тип даних. В пам'яті зберігається як адреса. Для створення потрібно спочатку створити об'єкт value type і потім передати його посилання. Наприклад:
    ```cpp
    int x = 5;
    int& reference = x;
    ```
Якщо змінити значення x, то reference, який містить посилання на x, теж повертатиме інше число, бо тепер за цим посиланням він дістає змінене значення. Якщо ж змінити вже значення ref, то х теж набуде нового значення, бо в пам'яті тепер за такою адресою зберігатиметься нове значення.
- pointer - також відноситься до посилального типу даних. Якщо у випадку reference можна змінити значення на яке він посилається, для pointer спочатку потрібно проевести розіменування. З іншого боку, reference не дає можливості отримати адресу посилання. Також, pointer може мати значення NULL, а reference завжди має посилатися на певне значення. Також pointer можна перевизначати, а посилання завжди посилається на певний об'єкт. Приклад створення: 
    int val = 5;
    int* pointer = &val;
Як показано в коді, якщо змінити значення об'єкту value type, то reference та pointer також зміняться, адже за посиланням, яке вони мають, тепер знаходиться нове значення. Якщо змінити значення reference або pointer, то об'єкт value type теж зміниться, оскільки в пам'яті на його місці тепер знаходиться нове значення.
### Як створити об'єкт на хіпі і на стеку?
Розглянемо це питання на прикладі програми в файлі stack_and_heap.cpp. В мові C++ існує три види виділення пам'яті - статичне, автоматичне та динамічне. Якщо спробувати створити масив так:
    ```cpp
    #include <iostream>
    using namespace std;
    class something
    {
        int size;
        int A [size];
        return 0;
    };
    int main()
    {
        something smth;
        cout << "Type a number: ";
        cin >> smth.size;
        cout<<smth.A<<endl;
        return 0;
    }
    ```
то програма поверне помилку: "a nonstatic member reference must be relative to a specific object". Вона виникає через те, що при використанні статичного або автоматичного виділення пам'яті в момент, коли скомпілюється та частина коду, що створює масив, має бути відома його довжина. Для того, щоб створити програму, де такий метод визначення масиву можливий, потрібно використати оператор new (або malloc). Тоді пам'ять буде виділятися не з стеку, який має обмежену кількість пам'яті (в залежності від компілятора та ОС), а з самої ОС, тобто довжина списку буде обмежуватися доступною фізичною пам'яттю. З іншого боку, використання динамічної пам'яті не дозволяє програмі автоматично звільнити пам'ять, як була зайнята цим списком, тому після виконання всіх необхідних дій потрібно використати оператор delete. 
Нижче наведено код програми, яка дозволить користувачу визначити довжину масиву:
    ```cpp
    #include <iostream>
    using namespace std;
    class heap
    {
    public:
        int size;
        int *B = new int[size];
    };
    int main()
    {
        heap heap_class;
        cout << "Type a number: ";
        cin >> heap_class.size;
        cout<<"Heap object"<<heap_class.B<<endl;
        delete [] heap_class.B;
        return 0;
    }
    ```
До переваг стеку, окрім автоматичного звільнення пам'яті, відноситься ще й те, що елементи в ньому впорядковані, тому отримати доступ до них можна швидше, ніж до об'єктів хіпу. Хіп, в свою чергу, дозволяє уникнути проблеми переповнення стеку (зрозуміло, що пам'ять в кожному з випадків буде мати обмеження, але як правило, хіп надає набагато більший її обсяг).
### Чи є в цій мові garbage collector?
Як було зазначено вище, при використанні хіпу пам'ять необхідно звільняти вручну. Це спричинено тим, що в мові C++ не передбачено прибиральник сміття. Це значить, що використовується ручне керування пам'яттю, тобто розробник сам вивільняє пам'ять від об'єктів, які вже не використовуються. Ця система має свої недоліки, наприклад, завислі вказівники та витоки пам'яті. 
Завислий вказівник - вказівник, який залишається в використанні після вивільнення пам'яті, яку для нього було виділено. Наприклад:
    ```cpp
    #include <iostream>
    using namespace std;

    int main()
    {
    int *ptr = new int(2);
    cout<<*ptr<<endl;
    delete ptr;
    cout<<*ptr<<endl;
    }
    ```
В цьому коді ptr видаляється, а потім викликається вказівник на нього. Він і буде завислим всказівником.
Витоки пам'яті - проблеми, які виникають через те, що пам'ять не вивільняється. Тобто програма завершує роботу, але розробник не видаляє об'єкти в хіпі, і вони продовжують займати пам'ять комп'ютера. Якщо таких об'єктів буде багато, то робота комп'ютеру може сповільнитися або програма може вичерпати доступний обсяг адресного простору і завершитися з помилкою. Наприклад:
    ```cpp
    #include <iostream>
    using namespace std;
    int main() 
    {
    int *ptr = new int(2);
    cout<<*ptr<<endl;
    cout<<*ptr<<endl;
    }
    ```
В коді вище створюється об'єкт на хіпі, але ни викликається оператор delete, тобто ptr продовжує займати пам'ять.
Все це може викликати настільки поважні проблеми, що в лютому 2024 року Агенство національної безпеки США закликало розробників відмовитися від мов C/C++ на користь тих, які забезпечують безпечну роботу з пам'яттю. Чому ж тоді C++ не має такої важливої функції, і чому ним продовжують користуватися?
Вперше прибиральник сміття з'явився в мові Lisp в 1959 році, а C++ було створено в 1985, тобто концепція прибиральника на той момент існувала вже давно. Втім, виявилося, що деякі функції мови не дозволяють створити для неї ефективний прибиральник. Наприклад, C++ дозволяє перетворення посилань/вказівників в інші типи даних (цілі числа, масиви байтів і т.п.), і через це було б складно відстежити всі посилання в коді. Отже мови, які мають прибиральник, мусять обмежувати свободу використання вказівників, адресної арифметики та перетворень типів вказівників до інших типів даних. Окрім того, прибиральник міг би дещо уповільнити роботу програми.
